{"version":3,"file":"extension.js","mappings":"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","sources":[".././src/proofreader.ts",".././src/splitter.ts","../external commonjs \"axios\"","../external commonjs \"dotenv\"","../external node-commonjs \"fs\"","../external node-commonjs \"path\"","../external commonjs \"vscode\"","../webpack/bootstrap","../webpack/runtime/compat get default export","../webpack/runtime/define property getters","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/make namespace object",".././src/extension.ts"],"sourcesContent":["/**\r\n * 校对工具模块\r\n */\r\n\r\nimport * as vscode from 'vscode';\r\nimport * as path from 'path';\r\nimport * as fs from 'fs';\r\nimport axios from 'axios';\r\nimport * as dotenv from 'dotenv';\r\n\r\n// 加载环境变量\r\ndotenv.config();\r\n\r\n// 内置的系统提示词\r\nconst DEFAULT_SYSTEM_PROMPT = `\r\n<proofreader-system-setting version=\"0.0.1\">\r\n<role-setting>\r\n\r\n你是一位精通中文的校对专家、语言文字专家，像杜永道等专家那样，能准确地发现文章的语言文字问题。\r\n\r\n你的语感也非常好，通过朗读就能感受到句子是否自然，是否潜藏问题。\r\n\r\n你知识渊博，能发现文中的事实错误。\r\n\r\n你工作细致、严谨，当你发现潜在的问题时，你会通过维基百科、《现代汉语词典》《辞海》等各种权威工具书来核对；如果涉及古代汉语和古代文化，你会专门查阅中华书局、上海古籍出版社等权威出版社出版的古籍，以及《王力古汉语字典》《汉语大词典》《辞源》《辞海》等工具书。\r\n\r\n你还学习过以下数据纠错数据集：\r\n\r\n1. [中文语法纠错数据集](https://huggingface.co/datasets/shibing624/CSC-gpt4)\r\n2. [校对标准A-Z](http://www.jiaodui.org/bbs/thread.php?fid=692)\r\n\r\n你的任务是对用户提供的目标文本（target）进行校对；校对时参考用户提供的参考资料（reference）和上下文（context）。\r\n\r\n</role-setting>\r\n<task>\r\n\r\n工作步骤是：\r\n\r\n1. 一句一句地仔细阅读甚至朗读每一句话，找出句子中可能存在的问题并改正；可能的问题有：\r\n    1. 汉字错误，如错误的形近字、同音和音近字，简体字和繁体字混用，异体字，等等；\r\n    2. 词语错误，如生造的词语、不规范的异形词，等等；\r\n    3. 句子的语法错误；\r\n    4. 指代错误；\r\n    5. 修辞错误；\r\n    6. 逻辑错误；\r\n    7. 标点符号错误；\r\n    8. 数字用法错误；\r\n    9. 语序错误；\r\n    10. 引文跟权威版本不一致；\r\n    11. 等等；\r\n2. 即使句子没有明显的错误，如果朗读过程中你感觉有下面的问题，也说明句子可能有错误，也要加以改正：\r\n    1. 句子不自然、不顺当；\r\n    2. 如果让你表达同一个意思，你通常不会这么说；\r\n3. 再整体检查如下错误并改正：\r\n    1. 逻辑错误；\r\n    2. 章法错误；\r\n    3. 事实错误；\r\n    4. 前后文不一致的问题；\r\n4. 核对参考资料和上下文中的信息，对照上下文中的格式，如果发现有错误或不一致，也要加以改正。\r\n\r\n</task>\r\n<output-format>\r\n\r\n输出修改后的目标文本（target），格式要求是：\r\n\r\n1. 用户提供的文本的格式可能是markdown、纯文本、TEX、ConTeXt，请保持文本原有的格式和标记；\r\n2. 原文的空行、换行、分段等格式保持不变；\r\n3. 不回答原文中的任何提问；\r\n4. 不给出任何说明或解释；\r\n\r\n</output-format>\r\n</proofreader-system-setting>\r\n`;\r\n\r\n/**\r\n * 限速器类，用于控制API调用频率\r\n */\r\nclass RateLimiter {\r\n    private interval: number;\r\n    private lastCallTime: number;\r\n\r\n    constructor(rpm: number) {\r\n        this.interval = 60 / rpm;\r\n        this.lastCallTime = 0;\r\n    }\r\n\r\n    async wait(): Promise<void> {\r\n        const currentTime = Date.now() / 1000;\r\n        const elapsed = currentTime - this.lastCallTime;\r\n        if (elapsed < this.interval) {\r\n            const waitTime = this.interval - elapsed;\r\n            await new Promise(resolve => setTimeout(resolve, waitTime * 1000));\r\n        }\r\n        this.lastCallTime = Date.now() / 1000;\r\n    }\r\n}\r\n\r\n/**\r\n * API调用接口\r\n */\r\ninterface ApiClient {\r\n    proofread(content: string, reference?: string): Promise<string | null>;\r\n}\r\n\r\n/**\r\n * Deepseek API客户端\r\n */\r\nexport class DeepseekClient implements ApiClient {\r\n    private apiKey: string;\r\n    private baseUrl: string;\r\n\r\n    constructor(model: 'deepseek-chat' | 'deepseek-v3') {\r\n        const config = vscode.workspace.getConfiguration('ai-proofread');\r\n        if (model === 'deepseek-chat') {\r\n            this.apiKey = config.get<string>('apiKeys.deepseekChat', '');\r\n            this.baseUrl = 'https://api.deepseek.com/v1';\r\n        } else {\r\n            this.apiKey = config.get<string>('apiKeys.deepseekV3', '');\r\n            this.baseUrl = 'https://dashscope.aliyuncs.com/api/v1';\r\n        }\r\n\r\n        if (!this.apiKey) {\r\n            throw new Error(`未配置${model === 'deepseek-chat' ? 'Deepseek Chat' : '阿里云 Deepseek V3'} API密钥，请在设置中配置`);\r\n        }\r\n    }\r\n\r\n    async proofread(content: string, reference: string = ''): Promise<string | null> {\r\n        const messages = [\r\n            { role: 'system', content: DEFAULT_SYSTEM_PROMPT }\r\n        ];\r\n\r\n        if (reference) {\r\n            messages.push(\r\n                { role: 'assistant', content: '' },\r\n                { role: 'user', content: reference }\r\n            );\r\n        }\r\n\r\n        messages.push(\r\n            { role: 'assistant', content: '' },\r\n            { role: 'user', content: content }\r\n        );\r\n\r\n        try {\r\n            const response = await axios.post(\r\n                `${this.baseUrl}/chat/completions`,\r\n                {\r\n                    model: this.baseUrl.includes('aliyuncs.com') ? 'deepseek-v3' : 'deepseek-chat',\r\n                    messages,\r\n                    temperature: 1,\r\n                },\r\n                {\r\n                    headers: {\r\n                        'Authorization': `Bearer ${this.apiKey}`,\r\n                        'Content-Type': 'application/json',\r\n                    }\r\n                }\r\n            );\r\n\r\n            let result = response.data.choices[0].message.content;\r\n            result = result.replace('\\n</target>', '').replace('<target>\\n', '');\r\n            return result;\r\n        } catch (error) {\r\n            console.error('API调用出错:', error);\r\n            return null;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Google API客户端\r\n */\r\nexport class GoogleClient implements ApiClient {\r\n    private apiKey: string;\r\n\r\n    constructor() {\r\n        const config = vscode.workspace.getConfiguration('ai-proofread');\r\n        this.apiKey = config.get<string>('apiKeys.google', '');\r\n\r\n        if (!this.apiKey) {\r\n            throw new Error('未配置Google API密钥，请在设置中配置');\r\n        }\r\n    }\r\n\r\n    async proofread(content: string, reference: string = ''): Promise<string | null> {\r\n        try {\r\n            const response = await axios.post(\r\n                'https://generativelanguage.googleapis.com/v1/models/gemini-pro:generateContent',\r\n                {\r\n                    contents: [\r\n                        {\r\n                            parts: [{ text: content }]\r\n                        }\r\n                    ],\r\n                    generationConfig: {\r\n                        temperature: 1,\r\n                    },\r\n                    safetySettings: [\r\n                        {\r\n                            category: 'HARM_CATEGORY_HARASSMENT',\r\n                            threshold: 'BLOCK_NONE'\r\n                        },\r\n                        {\r\n                            category: 'HARM_CATEGORY_HATE_SPEECH',\r\n                            threshold: 'BLOCK_NONE'\r\n                        },\r\n                        {\r\n                            category: 'HARM_CATEGORY_SEXUALLY_EXPLICIT',\r\n                            threshold: 'BLOCK_NONE'\r\n                        },\r\n                        {\r\n                            category: 'HARM_CATEGORY_DANGEROUS_CONTENT',\r\n                            threshold: 'BLOCK_NONE'\r\n                        }\r\n                    ]\r\n                },\r\n                {\r\n                    headers: {\r\n                        'Content-Type': 'application/json',\r\n                        'x-goog-api-key': this.apiKey,\r\n                    }\r\n                }\r\n            );\r\n\r\n            return response.data.candidates[0].content.parts[0].text;\r\n        } catch (error) {\r\n            console.error('API调用出错:', error);\r\n            return null;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * 处理进度统计\r\n */\r\ninterface ProcessStats {\r\n    totalCount: number;\r\n    processedCount: number;\r\n    totalLength: number;\r\n    processedLength: number;\r\n    unprocessedParagraphs: Array<{\r\n        index: number;\r\n        preview: string;\r\n    }>;\r\n}\r\n\r\n/**\r\n * 异步处理段落\r\n */\r\nexport async function processJsonFileAsync(\r\n    jsonInPath: string,\r\n    jsonOutPath: string,\r\n    options: {\r\n        startCount?: number | number[];\r\n        stopCount?: number;\r\n        model?: 'deepseek-chat' | 'deepseek-v3' | 'google';\r\n        rpm?: number;\r\n        maxConcurrent?: number;\r\n        onProgress?: (info: string) => void;\r\n    } = {}\r\n): Promise<ProcessStats> {\r\n    // 设置默认值\r\n    const {\r\n        startCount = 1,\r\n        stopCount,\r\n        model = 'deepseek-chat',\r\n        rpm = 15,\r\n        maxConcurrent = 3,\r\n        onProgress\r\n    } = options;\r\n\r\n    // 读取输入JSON文件\r\n    const inputParagraphs = JSON.parse(fs.readFileSync(jsonInPath, 'utf8'));\r\n    const totalCount = inputParagraphs.length;\r\n\r\n    // 初始化或读取输出JSON文件\r\n    let outputParagraphs: (string | null)[] = [];\r\n    if (fs.existsSync(jsonOutPath)) {\r\n        outputParagraphs = JSON.parse(fs.readFileSync(jsonOutPath, 'utf8'));\r\n        if (outputParagraphs.length !== totalCount) {\r\n            throw new Error(`输出JSON的长度与输入JSON的长度不同: ${outputParagraphs.length} != ${totalCount}`);\r\n        }\r\n    } else {\r\n        outputParagraphs = new Array(totalCount).fill(null);\r\n        fs.writeFileSync(jsonOutPath, JSON.stringify(outputParagraphs, null, 2), 'utf8');\r\n    }\r\n\r\n    // 确定要处理的段落索引\r\n    const indicesToProcess: number[] = [];\r\n    if (typeof startCount === 'number') {\r\n        const startIndex = startCount - 1;\r\n        const stopIndex = stopCount ? stopCount - 1 : totalCount - 1;\r\n        for (let i = startIndex; i <= stopIndex; i++) {\r\n            if (i < totalCount && outputParagraphs[i] === null) {\r\n                indicesToProcess.push(i);\r\n            }\r\n        }\r\n    } else {\r\n        for (const idx of startCount) {\r\n            const i = idx - 1;\r\n            if (0 <= i && i < totalCount && outputParagraphs[i] === null) {\r\n                indicesToProcess.push(i);\r\n            }\r\n        }\r\n    }\r\n\r\n    // 创建API客户端\r\n    const client: ApiClient = model === 'google' ? new GoogleClient() : new DeepseekClient(model);\r\n\r\n    // 创建限速器\r\n    const rateLimiter = new RateLimiter(rpm);\r\n\r\n    // 创建并发控制\r\n    const semaphore = new Array(maxConcurrent).fill(null);\r\n\r\n    // 处理段落\r\n    const processOne = async (index: number): Promise<void> => {\r\n        const paragraph = inputParagraphs[index];\r\n        const targetText = paragraph.target;\r\n        const referenceText = paragraph.reference || '';\r\n        const contextText = paragraph.context || '';\r\n\r\n        const haseContext = contextText && contextText.trim() !== targetText.trim();\r\n        const progressInfo = `处理 No. ${index + 1}/${totalCount}, Len ${targetText.length}` +\r\n            `${haseContext ? ` with context ${contextText.length}` : ''}`+\r\n            `${referenceText ? ` with reference ${referenceText.length}` : ''}:`+\r\n            `\\n${targetText.slice(0, 30)} ...\\n`+\r\n            `${'-'.repeat(40)}\\n`;\r\n        console.log(progressInfo);\r\n        if (onProgress) {\r\n            onProgress(progressInfo);\r\n        }\r\n\r\n        // 构建提示文本\r\n        let preText = referenceText ? `<reference>\\n${referenceText}\\n</reference>` : '';\r\n        if (haseContext) {\r\n            preText += `\\n<context>\\n${contextText}\\n</context>`;\r\n        }\r\n        const postText = `<target>\\n${targetText}\\n</target>`;\r\n\r\n        const startTime = Date.now();\r\n        await rateLimiter.wait();\r\n\r\n        const processedText = await client.proofread(postText, preText);\r\n        const elapsed = (Date.now() - startTime) / 1000;\r\n\r\n        if (processedText) {\r\n            outputParagraphs[index] = processedText;\r\n            fs.writeFileSync(jsonOutPath, JSON.stringify(outputParagraphs, null, 2), 'utf8');\r\n            const completeInfo = `完成 ${index + 1}/${totalCount} 长度 ${targetText.length} 用时 ${elapsed.toFixed(2)}s\\n${'-'.repeat(40)}\\n`;\r\n            console.log(completeInfo);\r\n            if (onProgress) {\r\n                onProgress(completeInfo);\r\n            }\r\n        } else {\r\n            const errorInfo = `段落 ${index + 1}/${totalCount}: 处理失败，跳过\\n${'-'.repeat(40)}\\n`;\r\n            console.log(errorInfo);\r\n            if (onProgress) {\r\n                onProgress(errorInfo);\r\n            }\r\n        }\r\n    };\r\n\r\n    // 并发处理所有段落\r\n    await Promise.all(\r\n        indicesToProcess.map(async (index) => {\r\n            const slot = await Promise.race(\r\n                semaphore.map((_, i) =>\r\n                    Promise.resolve(i)\r\n                )\r\n            );\r\n            semaphore[slot] = processOne(index).finally(() => {\r\n                semaphore[slot] = null;\r\n            });\r\n            await semaphore[slot];\r\n        })\r\n    );\r\n\r\n    // 生成处理统计\r\n    const processedCount = outputParagraphs.filter(p => p !== null).length;\r\n    const totalLength = inputParagraphs.reduce((sum: number, p: any) => sum + p.target.length, 0);\r\n    const processedLength = outputParagraphs.reduce((sum: number, p: string | null) => sum + (p ? p.length : 0), 0);\r\n    const unprocessedParagraphs = inputParagraphs\r\n        .map((p: any, i: number) => ({\r\n            index: i + 1,\r\n            preview: p.target.trim().split('\\n')[0].slice(0, 20)\r\n        }))\r\n        .filter((_: any, i: number) => outputParagraphs[i] === null);\r\n\r\n    // 生成Markdown文件\r\n    const mdFilePath = `${jsonOutPath}.md`;\r\n    const processedParagraphs = outputParagraphs.filter(p => p !== null);\r\n    fs.writeFileSync(mdFilePath, processedParagraphs.join('\\n\\n'), 'utf8');\r\n\r\n    return {\r\n        totalCount,\r\n        processedCount,\r\n        totalLength,\r\n        processedLength,\r\n        unprocessedParagraphs\r\n    };\r\n}","/**\r\n * 文本切分工具模块\r\n */\r\n\r\n/**\r\n * 将文本大致按长度切分（在指定长度前后最近一个空行处）\r\n * @param text 要切分的文本\r\n * @param cutBy 切分长度\r\n * @returns 切分后的文本列表\r\n */\r\nexport function cutTextByLength(text: string, cutBy: number = 600): string[] {\r\n    // 如果长度小于50，则按50字切分\r\n    cutBy = Math.max(50, cutBy);\r\n\r\n    // 按行分割文本\r\n    const lines = text.split('\\n');\r\n\r\n    // 存储切分后的文本\r\n    const result: string[] = [];\r\n    let currentChunk: string[] = [];\r\n    let currentLength = 0;\r\n\r\n    for (const line of lines) {\r\n        currentChunk.push(line);\r\n        currentLength += line.length;\r\n\r\n        // 如果当前块长度超过目标长度且遇到空行，则切分\r\n        if (currentLength >= cutBy && !line.trim()) {\r\n            result.push(currentChunk.join('\\n'));\r\n            currentChunk = [];\r\n            currentLength = 0;\r\n        }\r\n    }\r\n\r\n    // 添加最后一个块\r\n    if (currentChunk.length > 0) {\r\n        result.push(currentChunk.join('\\n'));\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n * 将markdown文本按标题级别切分\r\n * @param text markdown文本\r\n * @param levels 要切分的标题级别列表\r\n * @returns 切分后的文本列表\r\n */\r\nexport function splitMarkdownByTitle(text: string, levels: number[] = [2]): string[] {\r\n    // 按行分割文本\r\n    const lines = text.split('\\n');\r\n\r\n    // 存储切分后的段落\r\n    const rawParagraphs: string[] = [];\r\n    let currentParagraph: string[] = [];\r\n\r\n    for (const line of lines) {\r\n        // 检查是否为要切分的标题\r\n        let isTitleToCut = false;\r\n        for (const level of levels) {\r\n            if (line.startsWith('#'.repeat(level) + ' ')) {\r\n                isTitleToCut = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (isTitleToCut) {\r\n            // 如果当前段落不为空，添加到结果中\r\n            if (currentParagraph.length > 0) {\r\n                rawParagraphs.push(currentParagraph.join('\\n'));\r\n                currentParagraph = [];\r\n            }\r\n            // 将当前标题行添加到新段落\r\n            currentParagraph.push(line);\r\n        } else {\r\n            // 将当前行添加到当前段落\r\n            currentParagraph.push(line);\r\n        }\r\n    }\r\n\r\n    // 添加最后一个段落（如果存在）\r\n    if (currentParagraph.length > 0) {\r\n        rawParagraphs.push(currentParagraph.join('\\n'));\r\n    }\r\n\r\n    return rawParagraphs;\r\n}\r\n\r\n/**\r\n * 将markdown文本按标题级别切分，然后将每个段落按长度切分，保留完整上下文\r\n * @param text markdown文本\r\n * @param levels 要切分的标题级别列表\r\n * @param cutBy 切分长度\r\n * @returns 切分后的文本列表，每个元素包含完整上下文和目标文本\r\n */\r\nexport function splitMarkdownByTitleAndLengthWithContext(\r\n    text: string,\r\n    levels: number[] = [2],\r\n    cutBy: number = 600\r\n): Array<{ context: string; target: string }> {\r\n    // 先按标题切分\r\n    const sections = splitMarkdownByTitle(text, levels);\r\n\r\n    // 存储结果\r\n    const result: Array<{ context: string; target: string }> = [];\r\n\r\n    // 处理每个段落\r\n    for (const section of sections) {\r\n        // 将段落按长度切分\r\n        const pieces = cutTextByLength(section, cutBy);\r\n\r\n        // 为每个片段添加完整上下文\r\n        pieces.forEach(piece => {\r\n            result.push({\r\n                context: section,  // 完整的段落作为上下文\r\n                target: piece     // 切分后的片段作为目标文本\r\n            });\r\n        });\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n * 将列表中的超长段落切分为多个短段落\r\n * @param textList 段落列表\r\n * @param threshold 段落最大长度，超过此长度的段落将被拆分\r\n * @param cutBy 拆分长段落时的目标长度\r\n * @returns 处理后的段落列表\r\n */\r\nexport function cutTextInListByLength(textList: string[], threshold: number = 1500, cutBy: number = 800): string[] {\r\n    const textListShort: string[] = [];\r\n    for (const text of textList) {\r\n        if (text.length > threshold) {\r\n            textListShort.push(...cutTextByLength(text, cutBy));\r\n        } else {\r\n            textListShort.push(text);\r\n        }\r\n    }\r\n    return textListShort;\r\n}\r\n\r\n/**\r\n * 合并短段落到后一段\r\n * @param paragraphs 段落列表\r\n * @param minLength 段落最小长度，小于此长度的段落将被合并\r\n * @returns 合并短段落后的段落列表\r\n */\r\nexport function mergeShortParagraphs(paragraphs: string[], minLength: number = 100): string[] {\r\n    const result: string[] = [];\r\n    let tempParagraphs: string[] = [];\r\n\r\n    for (const para of paragraphs) {\r\n        const paraLength = para.length;\r\n\r\n        if (paraLength < minLength) {\r\n            // 短段落暂存\r\n            tempParagraphs.push(para);\r\n        } else {\r\n            // 正常长度段落\r\n            if (tempParagraphs.length > 0) {\r\n                // 如果有暂存段落，合并后添加\r\n                tempParagraphs.push(para);\r\n                result.push(tempParagraphs.join('\\n'));\r\n                tempParagraphs = [];\r\n            } else {\r\n                // 直接添加\r\n                result.push(para);\r\n            }\r\n        }\r\n    }\r\n\r\n    // 处理剩余的暂存段落\r\n    if (tempParagraphs.length > 0) {\r\n        result.push(tempParagraphs.join('\\n'));\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\nexport interface SplitOptions {\r\n    mode: 'length' | 'title' | 'title-length' | 'context';\r\n    cutBy?: number;\r\n    levels?: number[];\r\n    threshold?: number;\r\n    minLength?: number;\r\n}\r\n\r\n/**\r\n * 将文本切分并生成JSON和Markdown格式的输出\r\n * @param text 要切分的文本\r\n * @param options 切分选项\r\n * @returns 包含JSON和Markdown格式输出的对象\r\n */\r\nexport function splitText(\r\n    text: string,\r\n    options: {\r\n        mode: 'length' | 'title' | 'title-length' | 'context';\r\n        cutBy?: number;\r\n        levels?: number[];\r\n        threshold?: number;\r\n        minLength?: number;\r\n    }\r\n): {\r\n    jsonOutput: string;\r\n    markdownOutput: string;\r\n    segments: Array<{ target: string; context?: string }>;\r\n} {\r\n    let segments: Array<{ target: string; context?: string }>;\r\n\r\n    if (options.mode === 'length') {\r\n        // 按长度切分\r\n        const textList = cutTextByLength(text, options.cutBy);\r\n        segments = textList.map(x => ({ target: x }));\r\n    } else if (options.mode === 'title') {\r\n        // 按标题切分\r\n        const textList = splitMarkdownByTitle(text, options.levels);\r\n        segments = textList.map(x => ({ target: x }));\r\n    } else if (options.mode === 'context') {\r\n        // 按标题和长度切分，带上下文\r\n        segments = splitMarkdownByTitleAndLengthWithContext(text, options.levels, options.cutBy);\r\n    } else {\r\n        // 标题加长度切分：先按标题切分，然后处理长短段落\r\n        let textList = splitMarkdownByTitle(text, options.levels);\r\n        textList = cutTextInListByLength(textList, options.threshold, options.cutBy);\r\n        textList = mergeShortParagraphs(textList, options.minLength);\r\n        segments = textList.map(x => ({ target: x }));\r\n    }\r\n\r\n    // 生成JSON输出\r\n    const jsonOutput = JSON.stringify(segments, null, 2);\r\n\r\n    // 生成Markdown输出（用---分隔）\r\n    const markdownOutput = segments.map(x => x.target).join('\\n---\\n');\r\n\r\n    return {\r\n        jsonOutput,\r\n        markdownOutput,\r\n        segments\r\n    };\r\n}","module.exports = require(\"axios\");","module.exports = require(\"dotenv\");","module.exports = require(\"fs\");","module.exports = require(\"path\");","module.exports = require(\"vscode\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import * as vscode from 'vscode';\r\nimport * as path from 'path';\r\nimport * as fs from 'fs';\r\nimport { splitText } from './splitter';\r\nimport { processJsonFileAsync, GoogleClient, DeepseekClient } from './proofreader';\r\n\r\nexport function activate(context: vscode.ExtensionContext) {\r\n    console.log('AI Proofread extension is now active!');\r\n\r\n    // 通用的文件切分处理函数\r\n    async function handleFileSplit(\r\n        mode: 'length' | 'title' | 'title-length' | 'context',\r\n        editor: vscode.TextEditor,\r\n        document: vscode.TextDocument\r\n    ) {\r\n        const text = document.getText();\r\n        const config = vscode.workspace.getConfiguration('ai-proofread');\r\n\r\n        try {\r\n            let options: {\r\n                mode: 'length' | 'title' | 'title-length' | 'context';\r\n                cutBy?: number;\r\n                levels?: number[];\r\n                threshold?: number;\r\n                minLength?: number;\r\n            } = { mode };\r\n\r\n            if (mode === 'length') {\r\n                // 获取配置中的默认切分长度\r\n                const defaultLength = config.get<number>('defaultSplitLength', 600);\r\n\r\n                // 让用户选择切分长度\r\n                const inputLength = await vscode.window.showInputBox({\r\n                    prompt: '请输入切分长度（字符数）',\r\n                    value: defaultLength.toString(),\r\n                    validateInput: (value: string) => {\r\n                        const num = parseInt(value);\r\n                        if (isNaN(num)) {\r\n                            return '请输入有效的数字';\r\n                        }\r\n                        if (num < 50) {\r\n                            return '切分长度不能小于50字符';\r\n                        }\r\n                        return null;\r\n                    }\r\n                });\r\n\r\n                if (!inputLength) {\r\n                    return;\r\n                }\r\n                options.cutBy = parseInt(inputLength);\r\n            } else if (mode === 'title' || mode === 'title-length' || mode === 'context') {\r\n                // 获取配置中的默认标题级别\r\n                const defaultLevels = config.get<number[]>('defaultTitleLevels', [2]);\r\n\r\n                // 让用户选择标题级别\r\n                const inputLevels = await vscode.window.showInputBox({\r\n                    prompt: '请输入标题级别（用逗号分隔，如：1,2）',\r\n                    value: defaultLevels.join(','),\r\n                    validateInput: (value: string) => {\r\n                        const levels = value.split(',').map(x => parseInt(x.trim()));\r\n                        if (levels.some(isNaN)) {\r\n                            return '请输入有效的数字，用逗号分隔';\r\n                        }\r\n                        if (levels.some(x => x < 1 || x > 6)) {\r\n                            return '标题级别必须在1到6之间';\r\n                        }\r\n                        return null;\r\n                    }\r\n                });\r\n\r\n                if (!inputLevels) {\r\n                    return;\r\n                }\r\n                options.levels = inputLevels.split(',').map(x => parseInt(x.trim()));\r\n\r\n                if (mode === 'context') {\r\n                    // 获取带上下文切分的配置\r\n                    const defaultCutBy = config.get<number>('contextSplit.cutBy', 600);\r\n\r\n                    // 让用户选择切分长度\r\n                    const inputCutBy = await vscode.window.showInputBox({\r\n                        prompt: '请输入切分长度（字符数）',\r\n                        value: defaultCutBy.toString(),\r\n                        validateInput: (value: string) => {\r\n                            const num = parseInt(value);\r\n                            if (isNaN(num)) {\r\n                                return '请输入有效的数字';\r\n                            }\r\n                            if (num < 50) {\r\n                                return '切分长度不能小于50字符';\r\n                            }\r\n                            return null;\r\n                        }\r\n                    });\r\n\r\n                    if (!inputCutBy) {\r\n                        return;\r\n                    }\r\n                    options.cutBy = parseInt(inputCutBy);\r\n\r\n                } else if (mode === 'title-length') {\r\n                    // 获取标题加长度切分的配置\r\n                    options.threshold = config.get<number>('titleAndLengthSplit.threshold', 1500);\r\n                    options.cutBy = config.get<number>('titleAndLengthSplit.cutBy', 800);\r\n                    options.minLength = config.get<number>('titleAndLengthSplit.minLength', 120);\r\n\r\n                    // 让用户确认或修改参数\r\n                    const message = `将使用以下参数进行标题加长度切分：\\n\\n` +\r\n                        `- 标题级别: ${options.levels.join(',')}\\n` +\r\n                        `- 长度阈值: ${options.threshold} 字符\\n` +\r\n                        `- 切分长度: ${options.cutBy} 字符\\n` +\r\n                        `- 最小长度: ${options.minLength} 字符\\n\\n` +\r\n                        `是否继续？`;\r\n\r\n                    const confirm = await vscode.window.showInformationMessage(\r\n                        message,\r\n                        { modal: true },\r\n                        '继续',\r\n                        '修改参数'\r\n                    );\r\n\r\n                    if (!confirm) {\r\n                        return;\r\n                    }\r\n\r\n                    if (confirm === '修改参数') {\r\n                        // 让用户修改阈值\r\n                        const inputThreshold = await vscode.window.showInputBox({\r\n                            prompt: '请输入长度阈值（超过此长度的段落将被切分）',\r\n                            value: options.threshold.toString(),\r\n                            validateInput: (value: string) => {\r\n                                const num = parseInt(value);\r\n                                return isNaN(num) ? '请输入有效的数字' : null;\r\n                            }\r\n                        });\r\n                        if (!inputThreshold) return;\r\n                        options.threshold = parseInt(inputThreshold);\r\n\r\n                        // 让用户修改切分长度\r\n                        const inputCutBy = await vscode.window.showInputBox({\r\n                            prompt: '请输入切分长度（切分长段落时的目标长度）',\r\n                            value: options.cutBy.toString(),\r\n                            validateInput: (value: string) => {\r\n                                const num = parseInt(value);\r\n                                return isNaN(num) ? '请输入有效的数字' : null;\r\n                            }\r\n                        });\r\n                        if (!inputCutBy) return;\r\n                        options.cutBy = parseInt(inputCutBy);\r\n\r\n                        // 让用户修改最小长度\r\n                        const inputMinLength = await vscode.window.showInputBox({\r\n                            prompt: '请输入最小长度（小于此长度的段落将被合并）',\r\n                            value: options.minLength.toString(),\r\n                            validateInput: (value: string) => {\r\n                                const num = parseInt(value);\r\n                                return isNaN(num) ? '请输入有效的数字' : null;\r\n                            }\r\n                        });\r\n                        if (!inputMinLength) return;\r\n                        options.minLength = parseInt(inputMinLength);\r\n                    }\r\n                }\r\n            }\r\n\r\n            // 获取当前文件所在目录\r\n            const currentFileDir = path.dirname(document.uri.fsPath);\r\n            const baseFileName = path.basename(document.uri.fsPath, path.extname(document.uri.fsPath));\r\n\r\n            // 生成输出文件路径\r\n            const jsonFilePath = path.join(currentFileDir, `${baseFileName}.json`);\r\n            const markdownFilePath = path.join(currentFileDir, `${baseFileName}.json.md`);\r\n            const logFilePath = path.join(currentFileDir, `${baseFileName}.log`);\r\n\r\n            // 执行文本切分\r\n            const { jsonOutput, markdownOutput, segments } = splitText(text, options);\r\n\r\n            // 写入JSON文件\r\n            fs.writeFileSync(jsonFilePath, jsonOutput, 'utf8');\r\n\r\n            // 写入Markdown文件\r\n            fs.writeFileSync(markdownFilePath, markdownOutput, 'utf8');\r\n\r\n            // 显示结果统计\r\n            let statsMessage = '';\r\n            if (mode === 'length') {\r\n                statsMessage = `切分长度: ${options.cutBy}\\n\\n`;\r\n            } else if (mode === 'title') {\r\n                statsMessage = `切分标题级别: ${options.levels!.join(',')}\\n\\n`;\r\n            } else if (mode === 'context') {\r\n                statsMessage = `切分模式: 带上下文切分\\n` +\r\n                    `标题级别: ${options.levels!.join(',')}\\n` +\r\n                    `切分长度: ${options.cutBy}\\n\\n`;\r\n            } else {\r\n                statsMessage = `切分模式: 标题加长度切分\\n` +\r\n                    `标题级别: ${options.levels!.join(',')}\\n` +\r\n                    `长度阈值: ${options.threshold}\\n` +\r\n                    `切分长度: ${options.cutBy}\\n` +\r\n                    `最小长度: ${options.minLength}\\n\\n`;\r\n            }\r\n\r\n            statsMessage += `片段号\\t字符数\\t上下文长度\\t起始文字\\n${'-'.repeat(50)}\\n`;\r\n            let totalTargetLength = 0;\r\n            let totalContextLength = 0;\r\n            segments.forEach((segment, index) => {\r\n                const targetLength = segment.target.trim().length;\r\n                const contextLength = segment.context ? segment.context.trim().length : 0;\r\n                const firstLine = segment.target.trim().split('\\n')[0].slice(0, 15);\r\n                statsMessage += `No.${index + 1}\\t${targetLength}\\t${contextLength}\\t${firstLine}\\n`;\r\n                totalTargetLength += targetLength;\r\n                totalContextLength += contextLength;\r\n            });\r\n            if (mode === 'context') {\r\n                statsMessage += `\\n合计\\t${totalTargetLength}\\t${totalContextLength}\\t总计${totalTargetLength + totalContextLength}`;\r\n            } else {\r\n                statsMessage += `\\n合计\\t${totalTargetLength}`;\r\n            }\r\n\r\n            // 显示成功消息\r\n            vscode.window.showInformationMessage(`文件已成功切分！\\nJSON文件：${jsonFilePath}\\nMarkdown文件：${markdownFilePath}`);\r\n\r\n            // 写入统计信息\r\n            const timestamp = new Date().toLocaleString();\r\n            statsMessage = `\\n[${timestamp}]\\n${statsMessage}\\n${'='.repeat(50)}\\n`;\r\n            fs.appendFileSync(logFilePath, statsMessage, 'utf8');\r\n\r\n        } catch (error) {\r\n            vscode.window.showErrorMessage(`切分文件时出错：${error instanceof Error ? error.message : String(error)}`);\r\n        }\r\n    }\r\n\r\n    // 注册所有命令\r\n    let disposables = [\r\n        vscode.commands.registerCommand('ai-proofread.splitFileByLength', async () => {\r\n            const editor = vscode.window.activeTextEditor;\r\n            if (!editor) {\r\n                vscode.window.showInformationMessage('No active editor!');\r\n                return;\r\n            }\r\n            await handleFileSplit('length', editor, editor.document);\r\n        }),\r\n\r\n        vscode.commands.registerCommand('ai-proofread.splitFileByTitle', async () => {\r\n            const editor = vscode.window.activeTextEditor;\r\n            if (!editor) {\r\n                vscode.window.showInformationMessage('No active editor!');\r\n                return;\r\n            }\r\n            await handleFileSplit('title', editor, editor.document);\r\n        }),\r\n\r\n        vscode.commands.registerCommand('ai-proofread.splitFileWithContext', async () => {\r\n            const editor = vscode.window.activeTextEditor;\r\n            if (!editor) {\r\n                vscode.window.showInformationMessage('No active editor!');\r\n                return;\r\n            }\r\n            await handleFileSplit('context', editor, editor.document);\r\n        }),\r\n\r\n        vscode.commands.registerCommand('ai-proofread.splitFileByTitleAndLength', async () => {\r\n            const editor = vscode.window.activeTextEditor;\r\n            if (!editor) {\r\n                vscode.window.showInformationMessage('No active editor!');\r\n                return;\r\n            }\r\n            await handleFileSplit('title-length', editor, editor.document);\r\n        }),\r\n\r\n        vscode.commands.registerCommand('ai-proofread.proofreadFile', async () => {\r\n            const editor = vscode.window.activeTextEditor;\r\n            if (!editor) {\r\n                vscode.window.showInformationMessage('No active editor!');\r\n                return;\r\n            }\r\n\r\n            const document = editor.document;\r\n\r\n            // 检查文件是否为JSON\r\n            if (document.languageId !== 'json') {\r\n                vscode.window.showErrorMessage('请选择JSON文件进行校对！');\r\n                return;\r\n            }\r\n\r\n            try {\r\n                // 解析JSON文件以验证格式\r\n                const content = document.getText();\r\n                const jsonContent = JSON.parse(content);\r\n\r\n                // 验证JSON格式是否符合要求\r\n                if (!Array.isArray(jsonContent) || !jsonContent.every(item =>\r\n                    typeof item === 'object' && item !== null && 'target' in item\r\n                )) {\r\n                    vscode.window.showErrorMessage('JSON文件格式不正确！需要包含target字段的对象数组。');\r\n                    return;\r\n                }\r\n\r\n                // 获取当前文件路径\r\n                const currentFilePath = document.uri.fsPath;\r\n                const outputFilePath = currentFilePath.replace('.json', '.proofread.json');\r\n                const logFilePath = currentFilePath.replace('.json', '.proofread.log');\r\n\r\n                // 获取配置\r\n                const config = vscode.workspace.getConfiguration('ai-proofread');\r\n                const selectedModel = config.get<string>('proofread.model', 'deepseek-chat');\r\n                const rpm = config.get<number>('proofread.rpm', 15);\r\n                const maxConcurrent = config.get<number>('proofread.maxConcurrent', 3);\r\n\r\n                // 写入开始日志\r\n                const startTime = new Date().toLocaleString();\r\n                let logMessage = `\\n${'='.repeat(50)}\\n`;\r\n                logMessage += `校对开始时间: ${startTime}\\n`;\r\n                logMessage += `使用模型: ${selectedModel}\\n`;\r\n                logMessage += `每分钟请求数: ${rpm}\\n`;\r\n                logMessage += `最大并发数: ${maxConcurrent}\\n`;\r\n\r\n                // 统计字符数\r\n                const totalStats = jsonContent.reduce((acc: { target: number, context: number, reference: number }, item: any) => {\r\n                    acc.target += (item.target || '').length;\r\n                    acc.context += (item.context || '').length;\r\n                    acc.reference += (item.reference || '').length;\r\n                    return acc;\r\n                }, { target: 0, context: 0, reference: 0 });\r\n\r\n                logMessage += `\\n字符数统计:\\n`;\r\n                logMessage += `- 目标文本: ${totalStats.target} 字符\\n`;\r\n                logMessage += `- 上下文: ${totalStats.context} 字符\\n`;\r\n                logMessage += `- 参考文献: ${totalStats.reference} 字符\\n`;\r\n                logMessage += `- 总计: ${totalStats.target + totalStats.context + totalStats.reference} 字符\\n`;\r\n\r\n                logMessage += `${'='.repeat(50)}\\n\\n`;\r\n                fs.appendFileSync(logFilePath, logMessage, 'utf8');\r\n\r\n                // 检查API密钥是否已配置\r\n                let apiKey = '';\r\n                switch (selectedModel) {\r\n                    case 'deepseek-chat':\r\n                        apiKey = config.get<string>('apiKeys.deepseekChat', '');\r\n                        break;\r\n                    case 'deepseek-v3':\r\n                        apiKey = config.get<string>('apiKeys.deepseekV3', '');\r\n                        break;\r\n                    case 'google':\r\n                        apiKey = config.get<string>('apiKeys.google', '');\r\n                        break;\r\n                }\r\n\r\n                if (!apiKey) {\r\n                    const result = await vscode.window.showErrorMessage(\r\n                        `未配置${selectedModel}的API密钥，是否现在配置？`,\r\n                        '是',\r\n                        '否'\r\n                    );\r\n                    if (result === '是') {\r\n                        await vscode.commands.executeCommand('workbench.action.openSettings', 'ai-proofread.apiKeys');\r\n                    }\r\n                    return;\r\n                }\r\n\r\n                // 显示进度\r\n                await vscode.window.withProgress({\r\n                    location: vscode.ProgressLocation.Notification,\r\n                    title: \"正在校对文件...\",\r\n                    cancellable: false\r\n                }, async (progress) => {\r\n                    try {\r\n                        const stats = await processJsonFileAsync(currentFilePath, outputFilePath, {\r\n                            model: selectedModel as 'deepseek-chat' | 'deepseek-v3' | 'google',\r\n                            rpm,\r\n                            maxConcurrent,\r\n                            onProgress: (info: string) => {\r\n                                // 将进度信息写入日志\r\n                                fs.appendFileSync(logFilePath, info + '\\n', 'utf8');\r\n                                progress.report({ message: info });\r\n                            }\r\n                        });\r\n\r\n                        // 写入完成日志\r\n                        const endTime = new Date().toLocaleString();\r\n                        logMessage = `\\n${'='.repeat(50)}\\n`;\r\n                        logMessage += `校对结束时间: ${endTime}\\n`;\r\n                        logMessage += `总段落数: ${stats.totalCount}\\n`;\r\n                        logMessage += `已处理段落数、字数: ${stats.processedCount}/${stats.totalCount} (${(stats.processedCount/stats.totalCount*100).toFixed(2)}%), `;\r\n                        logMessage += `${stats.processedLength}/${stats.totalLength} (${(stats.processedLength/stats.totalLength*100).toFixed(2)}%)\\n`;\r\n                        logMessage += `未处理段落数: ${stats.totalCount - stats.processedCount}/${stats.totalCount}\\n`;\r\n\r\n                        // 记录未处理的段落\r\n                        if (stats.unprocessedParagraphs.length > 0) {\r\n                            logMessage += '\\n未处理的段落:\\n';\r\n                            stats.unprocessedParagraphs.forEach(p => {\r\n                                logMessage += `No.${p.index} \\n ${p.preview}...\\n\\n`;\r\n                            });\r\n                        }\r\n\r\n                        logMessage += `${'='.repeat(50)}\\n\\n`;\r\n                        fs.appendFileSync(logFilePath, logMessage, 'utf8');\r\n\r\n                        // 显示处理结果\r\n                        const message =\r\n                            `校对完成！\\n` +\r\n                            `总段落数: ${stats.totalCount}\\n` +\r\n                            `已处理段落数: ${stats.processedCount} (${(stats.processedCount/stats.totalCount*100).toFixed(2)}%)\\n` +\r\n                            `已处理字数: ${stats.processedLength} (${(stats.processedLength/stats.totalLength*100).toFixed(2)}%)\\n` +\r\n                            `未处理段落数: ${stats.totalCount - stats.processedCount}`;\r\n\r\n                        const result = await vscode.window.showInformationMessage(\r\n                            message,\r\n                            '查看结果',\r\n                            '查看未处理段落'\r\n                        );\r\n\r\n                        if (result === '查看结果') {\r\n                            // 打开校对后的文件\r\n                            const outputUri = vscode.Uri.file(outputFilePath);\r\n                            await vscode.workspace.openTextDocument(outputUri);\r\n                            await vscode.window.showTextDocument(outputUri);\r\n                        } else if (result === '查看未处理段落') {\r\n                            // 显示未处理的段落\r\n                            if (stats.unprocessedParagraphs.length > 0) {\r\n                                const items = stats.unprocessedParagraphs.map(p => ({\r\n                                    label: `No.${p.index}`,\r\n                                    description: p.preview + '...'\r\n                                }));\r\n                                await vscode.window.showQuickPick(items, {\r\n                                    placeHolder: '未处理的段落'\r\n                                });\r\n                            } else {\r\n                                vscode.window.showInformationMessage('没有未处理的段落！');\r\n                            }\r\n                        }\r\n                    } catch (error) {\r\n                        if (error instanceof Error && error.message.includes('未配置')) {\r\n                            const result = await vscode.window.showErrorMessage(\r\n                                error.message + '，是否现在配置？',\r\n                                '是',\r\n                                '否'\r\n                            );\r\n                            if (result === '是') {\r\n                                await vscode.commands.executeCommand('workbench.action.openSettings', 'ai-proofread.apiKeys');\r\n                            }\r\n                        } else {\r\n                            vscode.window.showErrorMessage(`校对过程中出错：${error instanceof Error ? error.message : String(error)}`);\r\n                        }\r\n                    }\r\n                });\r\n            } catch (error) {\r\n                vscode.window.showErrorMessage(`解析JSON文件时出错：${error instanceof Error ? error.message : String(error)}`);\r\n            }\r\n        }),\r\n\r\n        vscode.commands.registerCommand('ai-proofread.proofreadSelection', async () => {\r\n            const editor = vscode.window.activeTextEditor;\r\n            if (!editor) {\r\n                vscode.window.showInformationMessage('No active editor!');\r\n                return;\r\n            }\r\n\r\n            // 获取选中的文本\r\n            const selection = editor.selection;\r\n            const selectedText = editor.document.getText(selection);\r\n            if (!selectedText) {\r\n                vscode.window.showInformationMessage('请先选择要校对的文本！');\r\n                return;\r\n            }\r\n\r\n            try {\r\n                // 获取配置\r\n                const config = vscode.workspace.getConfiguration('ai-proofread');\r\n                const selectedModel = config.get<string>('proofread.model', 'deepseek-chat');\r\n                const defaultContextLevel = config.get<number>('proofread.defaultContextLevel', 0);\r\n\r\n                // 检查API密钥是否已配置\r\n                let apiKey = '';\r\n                switch (selectedModel) {\r\n                    case 'deepseek-chat':\r\n                        apiKey = config.get<string>('apiKeys.deepseekChat', '');\r\n                        break;\r\n                    case 'deepseek-v3':\r\n                        apiKey = config.get<string>('apiKeys.deepseekV3', '');\r\n                        break;\r\n                    case 'google':\r\n                        apiKey = config.get<string>('apiKeys.google', '');\r\n                        break;\r\n                }\r\n\r\n                if (!apiKey) {\r\n                    const result = await vscode.window.showErrorMessage(\r\n                        `未配置${selectedModel}的API密钥，是否现在配置？`,\r\n                        '是',\r\n                        '否'\r\n                    );\r\n                    if (result === '是') {\r\n                        await vscode.commands.executeCommand('workbench.action.openSettings', 'ai-proofread.apiKeys');\r\n                    }\r\n                    return;\r\n                }\r\n\r\n                // 让用户选择是否使用上下文和参考文件\r\n                const contextLevel = await vscode.window.showQuickPick(\r\n                    ['不使用上下文', '1 级标题', '2 级标题', '3 级标题', '4 级标题', '5 级标题', '6 级标题'],\r\n                    {\r\n                        placeHolder: '选择上下文范围（可选）',\r\n                        ignoreFocusOut: true\r\n                    }\r\n                );\r\n\r\n                let referenceFile: vscode.Uri[] | undefined;\r\n                const useReference = await vscode.window.showQuickPick(\r\n                    ['否', '是'],\r\n                    {\r\n                        placeHolder: '是否使用参考文件？',\r\n                        ignoreFocusOut: true\r\n                    }\r\n                );\r\n\r\n                if (useReference === '是') {\r\n                    referenceFile = await vscode.window.showOpenDialog({\r\n                        canSelectFiles: true,\r\n                        canSelectFolders: false,\r\n                        canSelectMany: false,\r\n                        filters: {\r\n                            'Text files': ['txt', 'md']\r\n                        },\r\n                        title: '选择参考文件'\r\n                    });\r\n                }\r\n\r\n                // 准备校对文本\r\n                let targetText = selectedText;\r\n                let contextText = '';\r\n                let referenceText = '';\r\n\r\n                // 如果选择了上下文级别，获取上下文\r\n                if (contextLevel && contextLevel !== '不使用上下文') {\r\n                    const level = contextLevel.charAt(0);\r\n                    const fullText = editor.document.getText();\r\n                    const lines = fullText.split('\\n');\r\n                    const selectionStartLine = selection.start.line;\r\n                    const selectionEndLine = selection.end.line;\r\n\r\n                    // 从本行开始向上查找最近的指定级别标题\r\n                    let startLine = selectionStartLine - 1;\r\n                    while (startLine > 0) {\r\n                        const line = lines[startLine - 1];\r\n                        if (line.startsWith(`${'#'.repeat(parseInt(level))} `)) {\r\n                            break;\r\n                        }\r\n                        startLine--;\r\n                    }\r\n\r\n                    // 向下查找下一个同级别标题\r\n                    let endLine = selectionEndLine;\r\n                    while (endLine < lines.length - 1) {\r\n                        const line = lines[endLine + 1];\r\n                        if (line.startsWith(`${'#'.repeat(parseInt(level))} `)) {\r\n                            break;\r\n                        }\r\n                        endLine++;\r\n                    }\r\n\r\n                    // 提取上下文\r\n                    contextText = lines.slice(startLine, endLine + 1).join('\\n');\r\n\r\n                }\r\n\r\n                // 如果选择了参考文件，读取参考文件内容\r\n                if (referenceFile && referenceFile[0]) {\r\n                    referenceText = fs.readFileSync(referenceFile[0].fsPath, 'utf8');\r\n                }\r\n\r\n                // 显示文本信息\r\n                const haseContext = contextText && contextText.trim() !== targetText.trim();\r\n                const progressInfo = `处理 Len ${targetText.length}` +\r\n                    `${haseContext ? ` with context ${contextText.length}` : ''}`+\r\n                    `${referenceText ? ` with reference ${referenceText.length}` : ''}`;\r\n                vscode.window.showInformationMessage(progressInfo);\r\n\r\n                // 构建提示文本\r\n                if (referenceText) {\r\n                    referenceText = `<reference>\\n${referenceText}\\n</reference>`;\r\n                }\r\n                if (contextText) {\r\n                    contextText = `<context>\\n${contextText}\\n</context>`;\r\n                }\r\n                targetText = `<target>\\n${targetText}\\n</target>`;\r\n\r\n                // 显示进度\r\n                await vscode.window.withProgress({\r\n                    location: vscode.ProgressLocation.Notification,\r\n                    title: \"正在校对文本...\",\r\n                    cancellable: false\r\n                }, async (progress) => {\r\n                    try {\r\n                        // 调用API进行校对\r\n                        const client = selectedModel === 'google'\r\n                            ? new GoogleClient()\r\n                            : new DeepseekClient(selectedModel as 'deepseek-chat' | 'deepseek-v3');\r\n                        const result = await client.proofread(targetText, referenceText + '\\n\\n' + contextText);\r\n\r\n                        if (result) {\r\n                            // 在新的编辑器中显示结果\r\n                            const document = await vscode.workspace.openTextDocument({\r\n                                content: result,\r\n                                language: editor.document.languageId\r\n                            });\r\n                            await vscode.window.showTextDocument(document, vscode.ViewColumn.Beside);\r\n                        } else {\r\n                            vscode.window.showErrorMessage('校对失败，请重试。');\r\n                        }\r\n                    } catch (error) {\r\n                        vscode.window.showErrorMessage(`校对过程中出错：${error instanceof Error ? error.message : String(error)}`);\r\n                    }\r\n                });\r\n            } catch (error) {\r\n                vscode.window.showErrorMessage(`校对过程中出错：${error instanceof Error ? error.message : String(error)}`);\r\n            }\r\n        })\r\n    ];\r\n\r\n    context.subscriptions.push(...disposables);\r\n}\r\n\r\nexport function deactivate() {}"],"names":["RateLimiter","constructor","rpm","this","interval","lastCallTime","wait","elapsed","Date","now","waitTime","Promise","resolve","setTimeout","DeepseekClient","model","config","getConfiguration","apiKey","get","baseUrl","Error","proofread","content","reference","messages","role","push","result","includes","temperature","headers","data","choices","message","replace","error","console","GoogleClient","contents","parts","text","generationConfig","safetySettings","category","threshold","candidates","async","processJsonFileAsync","jsonInPath","jsonOutPath","options","startCount","stopCount","maxConcurrent","onProgress","inputParagraphs","JSON","parse","totalCount","length","outputParagraphs","Array","fill","stringify","indicesToProcess","stopIndex","i","idx","client","rateLimiter","semaphore","all","map","index","slot","race","_","paragraph","targetText","target","referenceText","contextText","context","haseContext","trim","progressInfo","slice","repeat","log","preText","postText","startTime","processedText","completeInfo","toFixed","errorInfo","processOne","finally","processedCount","filter","p","totalLength","reduce","sum","processedLength","unprocessedParagraphs","preview","split","mdFilePath","processedParagraphs","join","cutTextByLength","cutBy","Math","max","lines","currentChunk","currentLength","line","splitMarkdownByTitle","levels","rawParagraphs","currentParagraph","isTitleToCut","level","startsWith","splitMarkdownByTitleAndLengthWithContext","sections","section","forEach","piece","cutTextInListByLength","textList","textListShort","mergeShortParagraphs","paragraphs","minLength","tempParagraphs","para","splitText","segments","mode","x","jsonOutput","markdownOutput","module","exports","require","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","n","getter","__esModule","d","a","definition","key","o","Object","defineProperty","enumerable","obj","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag","value","activate","handleFileSplit","editor","document","getText","defaultLength","inputLength","showInputBox","prompt","toString","validateInput","num","parseInt","isNaN","defaultLevels","inputLevels","some","defaultCutBy","inputCutBy","confirm","showInformationMessage","modal","inputThreshold","inputMinLength","currentFileDir","uri","fsPath","baseFileName","jsonFilePath","markdownFilePath","logFilePath","statsMessage","totalTargetLength","totalContextLength","segment","targetLength","contextLength","firstLine","timestamp","toLocaleString","showErrorMessage","String","disposables","registerCommand","activeTextEditor","languageId","jsonContent","isArray","every","item","currentFilePath","outputFilePath","selectedModel","logMessage","totalStats","acc","executeCommand","withProgress","location","Notification","title","cancellable","progress","stats","info","report","endTime","outputUri","file","openTextDocument","showTextDocument","items","label","description","showQuickPick","placeHolder","selection","selectedText","contextLevel","ignoreFocusOut","referenceFile","showOpenDialog","canSelectFiles","canSelectFolders","canSelectMany","filters","charAt","selectionStartLine","start","selectionEndLine","end","startLine","endLine","language","Beside","subscriptions","deactivate"],"sourceRoot":""}